{"version":3,"sources":["../bower_components/true/sass/true/_messages.scss","tests.css","../bower_components/true/sass/true/_assert.scss","core/_functions.scss"],"names":[],"mappings":"AAqDM,+BAAc;AAAd,yEAAc;ACnDpB;EC0EI,cAAsB;EACtB,yDCnDkD,EDiDrC;;AFtBX,+BAAc;AAAd,sEAAc;AC7CpB;ECoEI,cAAsB;EACtB,gDCjCyC,ED+B5B;;AFtBX,+BAAc;AAAd,gEAAc;ACvCpB;EC8DI,cAAsB;EACtB,kDCtB2C,EDoB9B;;AFtBX,yEAAc;AClCpB;ECyDI,cAAsB;EACtB,kDCb2C,EDW9B;;AFtBX,sCAAc;AAAd,8EAAc;AC5BpB;ECmDI,cAAsB;EACtB,4ECFuE,EDA1D;;AFtBX,uFAAc;ACvBpB;EC8CI,cAAsB;EACtB,4ECOuE,EDT1D;;AFtBX,4BAAc;AAAd,6DAAc;ACjBpB;ECwCI,cAAsB;EACtB,uDCkBgD,EDpBnC;;AFtBX,6BAAc;AAAd,kDAAc;ACXpB;ECkCI,cAAsB;EACtB,sDCsC+C,EDxClC;;AFtBX,gEAAc;ACNpB;EC6BI,cAAsB;EACtB,sDCwD+C,ED1DlC;;AFtBX,0BAAc;AAAd,yEAAc;ACApB;ECuBI,cAAsB;EACtB,mEC0E4D,ED5E/C;;AFtBX,8BAAc;AAAd,yEAAc;ACMpB;ECiBI,cAAsB;EACtB,qECwF8D,ED1FjD;;AFtBX,8BAAc;AAAd,oDAAc;ACYpB;ECWI,cAAsB;EACtB,0DCsGmD,EDxGtC;;AFtBX,6BAAc;AAAd,oCAAc;ACkBpB;ECKI,cAAsB;EACtB,yDCiHkD,EDnHrC;;AFtBX,6BAAc;AAAd,oCAAc;ACwBpB;ECDI,cAAsB;EACtB,yDC4HkD,ED9HrC;;AFtBX,6BAAc;AAAd,uDAAc;AC8BpB;ECPI,cAAsB;EACtB,yDCuIkD,EDzIrC;;AFtBX,8EAAc;ACmCpB;ECZI,cAAsB;EACtB,yDCgJkD,EDlJrC;;AFtBX,yFAAc;ACwCpB;ECjBI,cAAsB;EACtB,yDCyJkD,ED3JrC;;AFtBX,gCAAc;AAAd,wCAAc;AC8CpB;ECvBI,cAAsB;EACtB,qDCoK8C,EDtKjC;;AFtBX,mEAAc;ACmDpB;EC5BI,cAAsB;EACtB,qDC6K8C,ED/KjC;;AFtBX,mEAAc;ACwDpB;ECjCI,cAAsB;EACtB,qDCsL8C,EDxLjC;;AFtBX,iCAAc;AAAd,8DAAc;AC8DpB;ECvCI,cAAsB;EACtB,qECiM8D,EDnMjD;;AFtBX,mDAAc;ACmEpB;EC5CI,cAAsB;EACtB,qEC0M8D,ED5MjD;;AFtBX,gFAAc;ACwEpB;ECjDI,cAAsB;EACtB,qECmN8D,EDrNjD;;AFtBX,iCAAc;AAAd,yCAAc;AC8EpB;ECvDI,cAAsB;EACtB,sDC8N+C,EDhOlC;;AFtBX,8DAAc;ACmFpB;EC5DI,cAAsB;EACtB,sDCuO+C,EDzOlC;;AFtBX,mEAAc;ACwFpB;ECjEI,cAAsB;EACtB,sDCgP+C,EDlPlC;;AFtBX,2CAAc;AC6FpB;ECtEI,cAAsB;EACtB,sDCyP+C,ED3PlC;;AFtBX,kCAAc;AAAd,6EAAc;ACmGpB;EC5EI,cAAsB;EACtB,sDCoQ+C,EDtQlC;;AFtBX,+DAAc;ACwGpB;ECjFI,cAAsB;EACtB,sDC6Q+C,ED/QlC;;AFtBX,mEAAc;AC6GpB;ECtFI,cAAsB;EACtB,sDCsR+C,EDxRlC;;AFtBX,uCAAc;AAAd,0DAAc;ACmHpB;EC5FI,cAAsB;EACtB,qECiS8D,EDnSjD;;AFtBX,4DAAc;ACwHpB;ECjGI,cAAsB;EACtB,qEC0S8D,ED5SjD;;AFtBX,0BAAc;AAAd,iBAAc;AAAd,oBAAc;AAAd,mBAAc;AAAd,0BAAc","file":"results.css","sourcesContent":["// Messages\n// ========\n\n/// New line helper\n/// @access private\n/// @group x_private\n/// @type String\n$-tnl: '\\a ';\n\n\n/// Return a CSS selector for the current context\n/// @access private\n/// @group x_private\n/// @param {List} $scope - Scope\n/// @require {function} _true-context\n/// @return {String} - CSS selector\n@function _true-selector(\n  $scope\n) {\n  $selector: null;\n\n  @each $layer in $scope {\n    $this: '[data-#{$layer}=\"#{_true-context($layer)}\"]';\n    $selector: if($selector, '#{$selector} #{$this}', $this);\n  }\n\n  @return $selector;\n}\n\n\n/// Output a spacer comment\n/// @access private\n/// @group x_private\n/// @output A spacer comment\n@mixin _true-spacer() {\n/*\n*/\n}\n\n\n/// Output a message to CSS comments, or command line terminal (via debug/warn)\n/// @access private\n/// @group x_private\n/// @param {String} $message - Message to output\n/// @param {String} $output [comments] - Type of output, either `comments`, `terminal`, `debug` or `warn`\n/// @require {function} _true-str-split\n@mixin _true-message(\n  $message,\n  $output: comments\n) {\n  $lines: _true-str-split($message, $-tnl);\n  @if index($output, comments) {\n    @each $line in $lines {\n      /* #{$line} */\n    }\n  } @else if index($output, debug) or index($output, terminal) {\n    @each $line in $lines  {\n      @debug $line;\n    }\n  } @else if index($output, warn) {\n    @warn $message;\n    @each $line in $lines {\n      @if index($lines, $line) == length($lines) {\n        @warn $line;\n      } @else {\n        @debug $line;\n      }\n    }\n  }\n}\n","/* # map-deep-get ---------- */\n/* should return the value of the requested key from a deep nested map */\n[data-module=\"map-deep-get\"] [data-test=\"should return the value of the requested key from a deep nested map\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return the value from a deep nested map.\"; }\n\n/* # map-deep-set ---------- */\n/* should set the value of the requested key from a deep nested map */\n[data-module=\"map-deep-set\"] [data-test=\"should set the value of the requested key from a deep nested map\"] .assert-equal {\n  -result: PASS;\n  -description: \"Set a value to deep nested map.\"; }\n\n/* # map-has-keys ---------- */\n/* should return true if the requested keys from a map exists */\n[data-module=\"map-has-keys\"] [data-test=\"should return true if the requested keys from a map exists\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return true if a deep key exists.\"; }\n\n/* should return false if the requested keys from a map doesn't exists */\n[data-module=\"map-has-keys\"] [data-test=\"should return false if the requested keys from a map doesn't exists\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return true if a deep key exists.\"; }\n\n/* # map-has-nested-keys ---------- */\n/* should return true if the requested keys from a deeply nested map exists */\n[data-module=\"map-has-nested-keys\"] [data-test=\"should return true if the requested keys from a deeply nested map exists\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return true if map got all '$keys' nested with each others.\"; }\n\n/* should return false if the requested keys from a deeply nested map doesn't exists */\n[data-module=\"map-has-nested-keys\"] [data-test=\"should return false if the requested keys from a deeply nested map doesn't exists\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return true if map got all '$keys' nested with each others.\"; }\n\n/* # map-depth ---------- */\n/* should return the depth level of athe deeply nested map */\n[data-module=\"map-depth\"] [data-test=\"should return the depth level of athe deeply nested map\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return the level of depth the map has.\"; }\n\n/* # map-extend ---------- */\n/* should return a merged map of 2 or more maps */\n[data-module=\"map-extend\"] [data-test=\"should return a merged map of 2 or more maps\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return a merged map of 2 or more maps\"; }\n\n/* should return a merged map of 2 or more deeply nested maps */\n[data-module=\"map-extend\"] [data-test=\"should return a merged map of 2 or more deeply nested maps\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return a merged map of 2 or more maps\"; }\n\n/* # map-zip ---------- */\n/* should return a merged map from a list of keys and a list of values */\n[data-module=\"map-zip\"] [data-test=\"should return a merged map from a list of keys and a list of values\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return a map with merged lists of keys and values.\"; }\n\n/* # map-combine ---------- */\n/* should return a merged map from a list of keys and a list of values */\n[data-module=\"map-combine\"] [data-test=\"should return a merged map from a list of keys and a list of values\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return a map with combined lists of keys and values.\"; }\n\n/* # str-replace ---------- */\n/* should return a string with replaced substring */\n[data-module=\"str-replace\"] [data-test=\"should return a string with replaced substring\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return a string with replaced characters.\"; }\n\n/* # str-escape ---------- */\n/* should return a escaped string */\n[data-module=\"str-escape\"] [data-test=\"should return a escaped string\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return a string with escaped characters.\"; }\n\n/* # str-escape ---------- */\n/* should return a escaped string */\n[data-module=\"str-escape\"] [data-test=\"should return a escaped string\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return a string with escaped characters.\"; }\n\n/* # str-append ---------- */\n/* should return a string with an appended substring */\n[data-module=\"str-append\"] [data-test=\"should return a string with an appended substring\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return a string with appended substring.\"; }\n\n/* should return a string with an appended substring prepend by a seperator */\n[data-module=\"str-append\"] [data-test=\"should return a string with an appended substring prepend by a seperator\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return a string with appended substring.\"; }\n\n/* should return a string with an appended substring without seperator if string empty */\n[data-module=\"str-append\"] [data-test=\"should return a string with an appended substring without seperator if string empty\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return a string with appended substring.\"; }\n\n/* # str-transform ---------- */\n/* should return the transform string */\n[data-module=\"str-transform\"] [data-test=\"should return the transform string\"] .assert-equal {\n  -result: PASS;\n  -description: \"Outputs the transform string option.\"; }\n\n/* should modify x to transalteX and return the transform string */\n[data-module=\"str-transform\"] [data-test=\"should modify x to transalteX and return the transform string\"] .assert-equal {\n  -result: PASS;\n  -description: \"Outputs the transform string option.\"; }\n\n/* should modify y to transalteY and return the transform string */\n[data-module=\"str-transform\"] [data-test=\"should modify y to transalteY and return the transform string\"] .assert-equal {\n  -result: PASS;\n  -description: \"Outputs the transform string option.\"; }\n\n/* # str-transforms ---------- */\n/* should return none if the only passed value is a default */\n[data-module=\"str-transforms\"] [data-test=\"should return none if the only passed value is a default\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return true if the value is transform initial value.\"; }\n\n/* should return the transform string with value */\n[data-module=\"str-transforms\"] [data-test=\"should return the transform string with value\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return true if the value is transform initial value.\"; }\n\n/* should return the transform string with value and ignore the default value */\n[data-module=\"str-transforms\"] [data-test=\"should return the transform string with value and ignore the default value\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return true if the value is transform initial value.\"; }\n\n/* # str-transition ---------- */\n/* should return the transition string */\n[data-module=\"str-transition\"] [data-test=\"should return the transition string\"] .assert-equal {\n  -result: PASS;\n  -description: \"Outputs the transition string option.\"; }\n\n/* should return the full transition string in proper order */\n[data-module=\"str-transition\"] [data-test=\"should return the full transition string in proper order\"] .assert-equal {\n  -result: PASS;\n  -description: \"Outputs the transition string option.\"; }\n\n/* should ignore unrelated keys and return the transition string */\n[data-module=\"str-transition\"] [data-test=\"should ignore unrelated keys and return the transition string\"] .assert-equal {\n  -result: PASS;\n  -description: \"Outputs the transition string option.\"; }\n\n/* should return none if no related keys */\n[data-module=\"str-transition\"] [data-test=\"should return none if no related keys\"] .assert-equal {\n  -result: PASS;\n  -description: \"Outputs the transition string option.\"; }\n\n/* # str-transitions ---------- */\n/* should return none if the only passed value is a list of unrelated keys */\n[data-module=\"str-transitions\"] [data-test=\"should return none if the only passed value is a list of unrelated keys\"] .assert-equal {\n  -result: PASS;\n  -description: \"Outputs the transition string option.\"; }\n\n/* should return the full transitions string in proper order */\n[data-module=\"str-transitions\"] [data-test=\"should return the full transitions string in proper order\"] .assert-equal {\n  -result: PASS;\n  -description: \"Outputs the transition string option.\"; }\n\n/* should ignore unrelated keys and return the transition string */\n[data-module=\"str-transitions\"] [data-test=\"should ignore unrelated keys and return the transition string\"] .assert-equal {\n  -result: PASS;\n  -description: \"Outputs the transition string option.\"; }\n\n/* # is-transform-initial ---------- */\n/* should return a true if the value is an intial value */\n[data-module=\"is-transform-initial\"] [data-test=\"should return a true if the value is an intial value\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return true if the value is transform initial value.\"; }\n\n/* should return false if the value isn't an intial value */\n[data-module=\"is-transform-initial\"] [data-test=\"should return false if the value isn't an intial value\"] .assert-equal {\n  -result: PASS;\n  -description: \"Return true if the value is transform initial value.\"; }\n\n/* # SUMMARY ---------- */\n/* \"32 Tests:\" */\n/* \" - 32 Passed\" */\n/* \" - 0 Failed\" */\n/* -------------------- */\n","// Assert\n// ======\n\n\n/// Assert that a parameter is `true`\n/// @access public\n/// @group testing\n/// @param {*} $assert - Assert\n/// @param {String} $description [''] - Assert description\n/// @require {mixin} _true-fail-details\n/// @require {mixin} _true-assert-start\n/// @require {mixin} _true-assert-stop\n@mixin assert-true(\n  $assert,\n  $description: ''\n) {\n  @include _true-assert-start($description);\n  $result: if($assert, pass, fail);\n\n  .assert-true {\n    -result: to-upper-case($result);\n    -description: $description;\n\n    @if $result == fail {\n      @include _true-fail-details(true, $assert);\n    }\n  }\n\n  @include _true-assert-stop($result);\n}\n\n/// Assert that a parameter is `false`\n/// @access public\n/// @group testing\n/// @param {*} $assert - Assert\n/// @param {String} $description [''] - Assert description\n/// @require {mixin} _true-fail-details\n/// @require {mixin} _true-assert-start\n/// @require {mixin} _true-assert-stop\n@mixin assert-false(\n  $assert,\n  $description: ''\n) {\n  @include _true-assert-start($description);\n  $result: if($assert, fail, pass);\n\n  .assert-false {\n    -result: to-upper-case($result);\n    -description: $description;\n\n    @if $result == fail {\n      @include _true-fail-details(false, $assert);\n    }\n  }\n\n  @include _true-assert-stop($result);\n}\n\n/// /// Assert that two parameters are `equal`\n/// @access public\n/// @group testing\n/// @param {*} $assert - Assert\n/// @param {*} $expected - Expected result\n/// @param {String} $description [''] - Assert description\n/// @require {mixin} _true-fail-details\n/// @require {mixin} _true-assert-start\n/// @require {mixin} _true-assert-stop\n@mixin assert-equal(\n  $assert,\n  $expected,\n  $description: ''\n) {\n  @include _true-assert-start($description);\n  $result: if(_true-is-equal($assert, $expected), pass, fail);\n\n  .assert-equal {\n    -result: to-upper-case($result);\n    -description: $description;\n\n    @if $result == fail {\n      @include _true-fail-details($expected, $assert);\n    }\n  }\n\n  @include _true-assert-stop($result);\n}\n\n/// Assert that two parameters are `unequal`\n/// @access public\n/// @group testing\n/// @param {*} $assert - Assert\n/// @param {*} $expected - Expected result\n/// @param {String} $description [''] - Assert description\n/// @require {mixin} _true-fail-details\n/// @require {mixin} _true-assert-start\n/// @require {mixin} _true-assert-stop\n@mixin assert-unequal(\n  $assert,\n  $expected,\n  $description: ''\n) {\n  @include _true-assert-start($description);\n  $result: if(_true-is-equal($assert, $expected), fail, pass);\n\n  .assert-unequal {\n    -result: to-upper-case($result);\n    -description: $description;\n\n    @if $result == fail {\n      @include _true-fail-details($expected, $assert);\n    }\n  }\n\n  @include _true-assert-stop($result);\n}\n\n\n// CSS Output Tests\n// ----------------\n\n/// Define a CSS-output assertion\n/// @access public\n/// @group testing\n/// @param {String} $description - Assert description\n/// @content Use `input()` and `expect()` mixins to define blocks for comparison\n/// @require {mixin} _true-assert-start\n/// @require {mixin} _true-assert-stop\n/// @require {function} _true-selector\n@mixin assert(\n  $description\n) {\n  @include _true-assert-start($description);\n\n  #{_true-selector(assert)} {\n    @content;\n  }\n\n  @include _true-assert-stop(output-to-css);\n}\n\n/// Describe the test content to be evaluated\n/// The output will be compared against the results of the `expect()` mixin.\n/// @access public\n/// @group testing\n@mixin input {\n  .input {\n    @content;\n  }\n}\n\n/// Describe the output content to be expected.\n/// The output will be compared against the results of the `input()` mixin.\n/// @access public\n/// @group testing\n@mixin expect {\n  .expect {\n    @content;\n  }\n}\n\n\n// Assert Start\n// ------------\n\n/// True assert start helper\n/// @access private\n/// @group x_private\n/// @param {String} $name - Assert name\n/// @require {mixin} _true-context\n@mixin _true-assert-start(\n  $name\n) {\n  @include _true-context(assert, $name);\n}\n\n/// True assert sort helper\n/// @access private\n/// @group x_private\n/// @param {String} $result - Assert result\n/// @require {mixin} _true-context\n/// @require {mixin} _true-update\n@mixin _true-assert-stop(\n  $result\n) {\n  @include _true-update(test, $result);\n  @include _true-context(assert, null);\n}\n\n\n// Details\n// -------\n\n/// Fail details\n/// @access private\n/// @group x_private\n/// @param {*} $expected - Expected result\n/// @param {*} $returned - Returned result\n/// @param {Bool} $terminal [$true-terminal-output] - Whether or not to use terminal output\n/// @require $true-terminal-output\n/// @require {function} _true-context\n@mixin _true-fail-details(\n  $expected,\n  $returned,\n  $terminal: $true-terminal-output\n) {\n  $expected-type: type-of($expected);\n  $returned-type: type-of($returned);\n\n  -expected--#{$expected-type}: inspect($expected);\n  -returned--#{$returned-type}: inspect($returned);\n\n  @if $terminal {\n    @debug '[FAIL] #{_true-context(test)} » #{_true-context(assert)}';\n    @debug 'Expected #{$expected-type} »';\n    @debug inspect($expected);\n    @debug 'Returned #{$returned-type} »';\n    @debug inspect($returned);\n  }\n\n  @warn '#{_true-context(test)} » #{_true-context(assert)}';\n}\n","// Haleks — Tribar\n// https://haleks.ca\n// Licensed under MIT Open Source\n\n\n// Functions\n// =========\n\n// Map\n// ---\n\n$map: (\n    'first': (\n        'second': 100,\n        'third': 'testing',\n        'fourth': 500px,\n    ),\n    'fifth': 'test'\n);\n\n@include test-module('map-deep-get') {\n    @include test('should return the value of the requested key from a deep nested map') {\n        $actual: map-deep-get($map, 'first', 'second');\n        $expected: 100;\n\n        @include assert-equal($actual, $expected,\n            'Return the value from a deep nested map.'\n        );\n    }\n}\n\n@include test-module('map-deep-set') {\n    @include test('should set the value of the requested key from a deep nested map') {\n        $actual: map-deep-set($map, 'first', 'second', 500);\n        $expected: (\n            'first': (\n                'second': 500,\n                'third': 'testing',\n                'fourth': 500px,\n            ),\n            'fifth': 'test'\n        );\n\n        @include assert-equal($actual, $expected,\n            'Set a value to deep nested map.'\n        );\n    }\n}\n\n@include test-module('map-has-keys') {\n    @include test('should return true if the requested keys from a map exists') {\n        $actual: map-has-keys($map, 'first', 'fifth');\n        $expected: true;\n\n        @include assert-equal($actual, $expected,\n            'Return true if a deep key exists.'\n        );\n    }\n\n    @include test('should return false if the requested keys from a map doesn\\'t exists') {\n        $actual: map-has-keys($map, 'first', 'second');\n        $expected: false;\n\n        @include assert-equal($actual, $expected,\n            'Return true if a deep key exists.'\n        );\n    }\n}\n\n@include test-module('map-has-nested-keys') {\n    @include test('should return true if the requested keys from a deeply nested map exists') {\n        $actual: map-has-nested-keys($map, 'first', 'second');\n        $expected: true;\n\n        @include assert-equal($actual, $expected,\n            'Return true if map got all \\'$keys\\' nested with each others.'\n        );\n    }\n\n    @include test('should return false if the requested keys from a deeply nested map doesn\\'t exists') {\n        $actual: map-has-nested-keys($map, 'first', 'fifth');\n        $expected: false;\n\n        @include assert-equal($actual, $expected,\n            'Return true if map got all \\'$keys\\' nested with each others.'\n        );\n    }\n}\n\n@include test-module('map-depth') {\n    @include test('should return the depth level of athe deeply nested map') {\n        $actual: map-depth($map);\n        $expected: 2;\n\n        @include assert-equal($actual, $expected,\n            'Return the level of depth the map has.'\n        );\n    }\n}\n\n@include test-module('map-extend') {\n    @include test('should return a merged map of 2 or more maps') {\n        $actual: map-extend($map, ('sixth': 200), ('seveth': 150));\n        $expected: (\n            'first': (\n                'second': 100,\n                'third': 'testing',\n                'fourth': 500px,\n            ),\n            'fifth': 'test',\n            'sixth': 200,\n            'seveth': 150\n        );\n\n        @include assert-equal($actual, $expected,\n            'Return a merged map of 2 or more maps'\n        );\n    }\n\n    @include test('should return a merged map of 2 or more deeply nested maps') {\n        $actual: map-extend($map, ('first': ('second': 500)), ('sixth': 200), ('seveth': 150), true);\n        $expected: (\n            'first': (\n                'second': 500,\n                'third': 'testing',\n                'fourth': 500px,\n            ),\n            'fifth': 'test',\n            'sixth': 200,\n            'seveth': 150\n        );\n\n        @include assert-equal($actual, $expected,\n            'Return a merged map of 2 or more maps'\n        );\n    }\n}\n\n@include test-module('map-zip') {\n    @include test('should return a merged map from a list of keys and a list of values') {\n        $actual: map-zip(('first', 'fifth'), (('second': 100, 'third': 'testing', 'fourth': 500px), 'test'));\n        $expected: (\n            'first': (\n                'second': 100,\n                'third': 'testing',\n                'fourth': 500px,\n            ),\n            'fifth': 'test',\n        );\n\n        @include assert-equal($actual, $expected,\n            'Return a map with merged lists of keys and values.'\n        );\n    }\n}\n\n@include test-module('map-combine') {\n    @include test('should return a merged map from a list of keys and a list of values') {\n        $actual: map-combine(('first', 'fifth'), 'test');\n        $expected: (\n            'first': 'test',\n            'fifth': 'test',\n        );\n\n        @include assert-equal($actual, $expected,\n            'Return a map with combined lists of keys and values.'\n        );\n    }\n}\n\n// String\n// ------\n\n@include test-module('str-replace') {\n    @include test('should return a string with replaced substring') {\n        $actual: str-replace('hello you', 'you', 'world');\n        $expected: 'hello world';\n\n        @include assert-equal($actual, $expected,\n            'Return a string with replaced characters.'\n        );\n    }\n}\n\n@include test-module('str-escape') {\n    @include test('should return a escaped string') {\n        $actual: str-escape('hello world.');\n        $expected: 'hello world\\\\.';\n\n        @include assert-equal($actual, $expected,\n            'Return a string with escaped characters.'\n        );\n    }\n}\n\n@include test-module('str-escape') {\n    @include test('should return a escaped string') {\n        $actual: str-escape('hello world.');\n        $expected: 'hello world\\\\.';\n\n        @include assert-equal($actual, $expected,\n            'Return a string with escaped characters.'\n        );\n    }\n}\n\n@include test-module('str-append') {\n    @include test('should return a string with an appended substring') {\n        $actual: str-append('hello', 'world');\n        $expected: 'helloworld';\n\n        @include assert-equal($actual, $expected,\n            'Return a string with appended substring.'\n        );\n    }\n\n    @include test('should return a string with an appended substring prepend by a seperator') {\n        $actual: str-append('hello', 'world', ' ');\n        $expected: 'hello world';\n\n        @include assert-equal($actual, $expected,\n            'Return a string with appended substring.'\n        );\n    }\n\n    @include test('should return a string with an appended substring without seperator if string empty') {\n        $actual: str-append('', 'world', ' ');\n        $expected: 'world';\n\n        @include assert-equal($actual, $expected,\n            'Return a string with appended substring.'\n        );\n    }\n}\n\n@include test-module('str-transform') {\n    @include test('should return the transform string') {\n        $actual: str-transform('rotate', 10deg);\n        $expected: 'rotate(10deg)';\n\n        @include assert-equal($actual, $expected,\n            'Outputs the transform string option.'\n        );\n    }\n\n    @include test('should modify x to transalteX and return the transform string') {\n        $actual: str-transform('x', 10);\n        $expected: 'translateX(10)';\n\n        @include assert-equal($actual, $expected,\n            'Outputs the transform string option.'\n        );\n    }\n\n    @include test('should modify y to transalteY and return the transform string') {\n        $actual: str-transform('y', 10);\n        $expected: 'translateY(10)';\n\n        @include assert-equal($actual, $expected,\n            'Outputs the transform string option.'\n        );\n    }\n}\n\n@include test-module('str-transforms') {\n    @include test('should return none if the only passed value is a default') {\n        $actual: str-transforms(('y': 0));\n        $expected: none;\n\n        @include assert-equal($actual, $expected,\n            'Return true if the value is transform initial value.'\n        );\n    }\n\n    @include test('should return the transform string with value') {\n        $actual: str-transforms(('x': 10, 'scaleX': 10));\n        $expected: 'translateX(10) scaleX(10)';\n\n        @include assert-equal($actual, $expected,\n            'Return true if the value is transform initial value.'\n        );\n    }\n\n    @include test('should return the transform string with value and ignore the default value') {\n        $actual: str-transforms(('y': 0, 'x': 10, 'scaleX': 10));\n        $expected: 'translateX(10) scaleX(10)';\n\n        @include assert-equal($actual, $expected,\n            'Return true if the value is transform initial value.'\n        );\n    }\n}\n\n@include test-module('str-transition') {\n    @include test('should return the transition string') {\n        $actual: str-transition(('property': 'all', 'duration': 1s));\n        $expected: 'all 1s';\n\n        @include assert-equal($actual, $expected,\n            'Outputs the transition string option.'\n        );\n    }\n\n    @include test('should return the full transition string in proper order') {\n        $actual: str-transition(('property': 'all', 'delay': 1s, 'function': 'ease', 'duration': 1s));\n        $expected: 'all 1s ease 1s';\n\n        @include assert-equal($actual, $expected,\n            'Outputs the transition string option.'\n        );\n    }\n\n    @include test('should ignore unrelated keys and return the transition string') {\n        $actual: str-transition(('property': 'all', 'duration': 1s, 'test': 'unrelated'));\n        $expected: 'all 1s';\n\n        @include assert-equal($actual, $expected,\n            'Outputs the transition string option.'\n        );\n    }\n\n    @include test('should return none if no related keys') {\n        $actual: str-transition(('unrelated-key': 1s, 'unrelated': 'test'));\n        $expected: none;\n\n        @include assert-equal($actual, $expected,\n            'Outputs the transition string option.'\n        );\n    }\n}\n\n@include test-module('str-transitions') {\n    @include test('should return none if the only passed value is a list of unrelated keys') {\n        $actual: str-transitions((('unrelated-key': 1s, 'unrelated': 'test'), ('unrelated-key': 1s, 'unrelated': 'test')));\n        $expected: none;\n\n        @include assert-equal($actual, $expected,\n            'Outputs the transition string option.'\n        );\n    }\n\n    @include test('should return the full transitions string in proper order') {\n        $actual: str-transitions((('property': 'height', 'delay': 1s, 'function': 'ease', 'duration': 1s), ('property': 'width', 'function': 'ease', 'delay': 1s, 'duration': 1s)));\n        $expected: 'height 1s ease 1s,width 1s ease 1s';\n\n        @include assert-equal($actual, $expected,\n            'Outputs the transition string option.'\n        );\n    }\n\n    @include test('should ignore unrelated keys and return the transition string') {\n        $actual: str-transitions((('property': 'height', 'unrelated': 1s, 'no-function': 'ease', 'duration': 1s), ('property': 'width', 'function': 'ease', 'delay': 1s, 'duration': 1s)));\n        $expected: 'height 1s,width 1s ease 1s';\n\n        @include assert-equal($actual, $expected,\n            'Outputs the transition string option.'\n        );\n    }\n}\n\n@include test-module('is-transform-initial') {\n    @include test('should return a true if the value is an intial value') {\n        $actual: is-transform-initial('y', 0);\n        $expected: true;\n\n        @include assert-equal($actual, $expected,\n            'Return true if the value is transform initial value.'\n        );\n    }\n\n    @include test('should return false if the value isn\\'t an intial value') {\n        $actual: is-transform-initial('degrees', 10deg);\n        $expected: false;\n\n        @include assert-equal($actual, $expected,\n            'Return true if the value is transform initial value.'\n        );\n    }\n}\n"],"sourceRoot":"/source/"}